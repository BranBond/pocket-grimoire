<!doctype html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Pad</title>

<style>
*,
*::before,
*::after {
    box-sizing: border-box;
}

html,
body {
    font-size: 1rem;
    line-height: 1.4;
    font-family: Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    height: 100%;
}

.pad {
    border: 2px solid #000;
    height: 80vh;

    position: relative;
    resize: vertical;
    overflow: scroll;
    background-color: #333;
}

.pad-wrapper {
    position: relative;
}

.pad-wrapper__icon {
    color: #fff;
    position: absolute;
    right: 0;
    bottom: 2px;
    pointer-events: none;
    width: 1em;
    aspect-ratio: 1 / 1;
}

.token {
    --color: 0 0 0;
    --left: 0;
    --top: 0;
    --z-index: 0;
    width: 60px;
    aspect-ratio: 1 / 1;
    border-radius: 50%;
    border: 2px solid rgb(var(--color));
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgb(var(--color) / 20%);
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;

    position: absolute;
    cursor: move;
    left: calc(var(--left) * 1px);
    top: calc(var(--top) * 1px);
    z-index: var(--z-index);
}

.token--character {
    --color: 255 0 0;
    width: clamp(60px, 100vw / 6, 150px);
}

.token--reminder {
    --color: 0 0 255;
    width: clamp(45px, 100vw / 9, 125px);
}
</style>

</head>
<body>

<h1>Pocket Grimoire</h1>

<div class="pad-wrapper">
    <div class="pad"></div>
    <!-- https://fontawesome.com/v5.15/icons/arrows-alt-v?style=solid -->
    <svg aria-hidden="true" focusable="false" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="pad-wrapper__icon"><path fill="currentColor" d="M214.059 377.941H168V134.059h46.059c21.382 0 32.09-25.851 16.971-40.971L144.971 7.029c-9.373-9.373-24.568-9.373-33.941 0L24.971 93.088c-15.119 15.119-4.411 40.971 16.971 40.971H88v243.882H41.941c-21.382 0-32.09 25.851-16.971 40.971l86.059 86.059c9.373 9.373 24.568 9.373 33.941 0l86.059-86.059c15.12-15.119 4.412-40.971-16.97-40.971z" class=""></path></svg>
</div>

<button type="button" id="add-token">Add token</button>
<button type="button" id="add-reminder">Add reminder</button>
<button type="button" id="reset-height">Reset pad height</button>

<script>

const pad = document.querySelector(".pad");
const noop = () => {};
let dragHandler = noop;
let xOffset = 0;
let yOffset = 0;
let {
    left: padLeft,
    top: padTop,
    width: padWidth,
    height: padHeight
} = pad.getBoundingClientRect();
let isDragging = false;

function clamp(min, value, max) {
    return Math.max(min, Math.min(value, max));
}

function startDrag(element, event) {

    const {
        type,
        clientX,
        clientY,
        targetTouches
    } = event;
    const {
        left,
        top
    } = element.getBoundingClientRect();

    dragHandler = (event) => dragObject(element, event);

    if (type === "mousedown") {

        xOffset = clientX - left + padLeft;
        yOffset = clientY - top + padTop;
        window.addEventListener("mousemove", dragHandler);

    } else if (type === "touchstart" && targetTouches.length) {

        xOffset = targetTouches[0].clientX - left + padLeft;
        yOffset = targetTouches[0].clientY - top + padTop;
        window.addEventListener("touchmove", dragHandler, { passive: false });

    }

}

function dragObject(element, event) {

    event.preventDefault();

    const {
        type,
        clientX,
        clientY,
        targetTouches
    } = event;
    let leftValue = 0;
    let topValue = 0;
    const {
        width,
        height
    } = element.getBoundingClientRect();

    if (type === "mousemove") {

        leftValue = clientX - xOffset;
        topValue = clientY - yOffset;
        isDragging = true;

    } else if (type === "touchmove" && targetTouches.length) {

        leftValue = targetTouches[0].clientX - xOffset;
        topValue = targetTouches[0].clientY - yOffset;

    }

    element.style.setProperty("--left", clamp(0, leftValue, padWidth - width));
    element.style.setProperty("--top", clamp(0, topValue, padHeight - height));

}

const tokenEvents = {

    zIndex: 1,

    onMousedown(token, e) {

        startDrag(token, e);
        token.style.setProperty("--z-index", this.zIndex);
        this.zIndex += 1;

    },

    onClick(token, e) {

        if (isDragging) {
            return;
        }

        window.alert(token.textContent.trim());

    },

    handleEvent(e) {

        const token = e.target.closest(".token");

        if (!token) {
            return;
        }

        switch (e.type) {

        case "mousedown":
        case "touchstart":
            this.onMousedown(token, e);
            break;

        case "click":
            this.onClick(token, e);
            break;

        }

    }

};
document.addEventListener("mousedown", tokenEvents);
document.addEventListener("touchstart", tokenEvents);
document.addEventListener("click", tokenEvents);

function endDragging() {

    if (dragHandler !== noop) {

        window.removeEventListener("mousemove", dragHandler);
        window.removeEventListener("touchmove", dragHandler, { passive: false });
        dragHandler = noop;

        // The order of events is mousedown -> mouseup -> click. This means that
        // we need to delay the resetting of `isDragging` so that the handler
        // attached to the click event listener doesn't trigger after dragging.
        // This only seems to be an issue on desktop, mobile seems to be fine.
        window.requestAnimationFrame(() => isDragging = false);

    }

}

document.addEventListener("mouseup", endDragging);
document.addEventListener("touchend", endDragging);

function updatePadDimensions() {

    const rect = pad.getBoundingClientRect();

    padLeft = rect.left;
    padTop = rect.top;
    padWidth = rect.width;
    padHeight = rect.height;

}

window.addEventListener("resize", updatePadDimensions);
const styleObserver = new MutationObserver(updatePadDimensions);
styleObserver.observe(pad, {
    attributes: true,
    attributeFilter: ["style"]
});

let tokens = 1;

document.getElementById("add-token").addEventListener("click", () => {

    const token = document.createElement("button");
    token.type = "button";
    token.classList.add("token", "token--character");
    token.textContent = tokens;
    tokens += 1;

    pad.append(token);

});

const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
let letterIndex = 0;

document.getElementById("add-reminder").addEventListener("click", () => {

    const reminder = document.createElement("button");
    reminder.type = "button";
    reminder.classList.add("token", "token--reminder");
    reminder.textContent = letters[letterIndex];
    letterIndex = (letterIndex + 1) % letters.length;

    pad.append(reminder);

});

document.getElementById("reset-height").addEventListener("click", () => {
    pad.style.height = "";
});
</script>

</body>
</html>
